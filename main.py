import uuid
from hmac import compare_digest

from dotenv import load_dotenv
from fasthtml.common import *
from langchain_together import ChatTogether
from pytube import YouTube

from extract_transcript import Transcript
from rag import Rag
from summary import Summary

load_dotenv()

# You can use any database you want; it'll be easier if you pick a lib that supports the MiniDataAPI spec.
# Here we are using SQLite, with the FastLite library, which supports the MiniDataAPI spec.
db = database('data/uchats.db')
videos,users = db.t.videos, db.t.users
if videos not in db.t:
    # You can pass a dict, or kwargs, to most MiniDataAPI methods.
    users.create(dict(name=str, pwd=str), pk='name')
    videos.create(dict(video_id=str, summary=str, name=str, session_id=str), pk='video_id')  #need to be changed
Videa,User = videos.dataclass(),users.dataclass()

# Global balance (NB: resets every restart)
global_balance = 10

login_redir = RedirectResponse('/login', status_code=303)

# The `before` function is a *Beforeware* function. These are functions that run before a route handler is called.
def before(req, sess):
    # This sets the `auth` attribute in the request scope, and gets it from the session.
    # The session is a Starlette session, which is a dict-like object which is cryptographically signed,
    # so it can't be tampered with.
    # The `auth` key in the scope is automatically provided to any handler which requests it, and can not
    # be injected by the user using query params, cookies, etc, so it should be secure to use.
    auth = req.scope['auth'] = sess.get('auth', None)
    # If the session key is not there, it redirects to the login page.
    if not auth: return login_redir
    # `xtra` is part of the MiniDataAPI spec. It adds a filter to queries and DDL statements,
    # to ensure that the user can only see/edit their own videos.
    videos.xtra(name=auth)

# We will use this in our `exception_handlers` dict
def _not_found(req, exc): return Titled('Oh no!', Div('We could not find that page :('))

bware = Beforeware(before, skip=[r'/favicon\.ico', r'/static/.*', r'.*\.css', '/login'])

# Set up the app, including daisyui and tailwind for the chat component
hdrs = (picolink, 
        Script(src="https://cdn.tailwindcss.com"),
        Link(rel="stylesheet", href="https://cdn.jsdelivr.net/npm/daisyui@4.11.1/dist/full.min.css"),
        Style("""
        .scrollable-text {
            width: 500px;           /* Set the width of the box */
            height: 300px;          /* Set the height of the box */
            overflow-y: auto;       /* Enable vertical scrolling */
            border: 1px solid #ccc; /* Optional: Add border */
            padding: 10px;          /* Optional: Add padding */
            color: white;           /* White text color */
            border-radius: 5px;     /* Optional: Rounded corners */
        }
        .scrollable-text::-webkit-scrollbar {
            width: 8px; /* Width of the scrollbar */
        }
        .scrollable-text::-webkit-scrollbar-thumb {
            background-color: #555; /* Scrollbar thumb color */
            border-radius: 4px;     /* Rounded corners for scrollbar thumb */
        }
        .scrollable-text::-webkit-scrollbar-track {
            background: #444; /* Track color */
        }
    """) )

app = FastHTML(before=bware,
               exception_handlers={404: _not_found},
               hdrs=hdrs, 
               cls="p-4 max-w-lg mx-auto")

rt = app.route

# For instance, this function handles GET requests to the `/login` path.
@rt("/login")
def get():
    # This creates a form with two input fields, and a submit button.
    # All of these components are `FT` objects. All HTML tags are provided in this form by FastHTML.
    # If you want other custom tags (e.g. `MyTag`), they can be auto-generated by e.g
    # `from fasthtml.components import MyTag`.
    # Alternatively, manually call e.g `ft(tag_name, *children, **attrs)`.
    frm = Form(
        # Tags with a `name` attr will have `name` auto-set to the same as `id` if not provided
        Input(id='name', placeholder='Username'),
        Input(id='pwd', type='password', placeholder='Password'),
        Button('login'),
        action='/login', method='post')
    # If a user visits the URL directly, FastHTML auto-generates a full HTML page.
    # However, if the URL is accessed by HTMX, then one HTML partial is created for each element of the tuple.
    # To avoid this auto-generation of a full page, return a `HTML` object, or a Starlette `Response`.
    # `Titled` returns a tuple of a `Title` with the first arg and a `Container` with the rest.
    # See the comments for `Title` later for details.
    return Titled("Login", frm)

@dataclass
class Login: name:str; pwd:str

@rt("/login")
def post(login:Login, sess):
    if not login.name or not login.pwd: return login_redir
    # Indexing into a MiniDataAPI table queries by primary key, which is `name` here.
    # It returns a dataclass object, if `dataclass()` has been called at some point, or a dict otherwise.
    try: u = users[login.name]
    # If the primary key does not exist, the method raises a `NotFoundError`.
    # Here we use this to just generate a user -- in practice you'd probably to redirect to a signup page.
    except NotFoundError: u = users.insert(login)
    # This compares the passwords using a constant time string comparison
    # https://sqreen.github.io/DevelopersSecurityBestPractices/timing-attack/python
    if not compare_digest(u.pwd.encode("utf-8"), login.pwd.encode("utf-8")): return login_redir
    # Because the session is signed, we can securely add information to it. It's stored in the browser cookies.
    # If you don't pass a secret signing key to `FastHTML`, it will auto-generate one and store it in a file `./sesskey`.
    sess['auth'] = u.name
    return RedirectResponse('/', status_code=303)

@app.get("/logout")
def logout(sess):
    del sess['auth']
    return login_redir



# Set up a chat model (https://claudette.answer.ai/)
llm = ChatTogether(model='meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo')


def get_video_title(video_link:str):
    yt = YouTube(video_link)
    return yt.title

def link_to_videoid(link:str):
    return link.split('watch?v=')[1]

def link_to_embed(link:str):
    return f"https://www.youtube.com/embed/{link_to_videoid(link)}"

# The input link for the youtube video
def LinkInput():
    return Input(name='video_link', id='link-input', placeholder="Enter a youtube video link", hx_swap_oob='true')


def VideoFrame(video_link:str):
    return Iframe(src=link_to_embed(video_link), id='video-frame', width="560", height="315")

# Chat message component (renders a chat bubble)
def ChatMessage(msg, user):
    bubble_class = "chat-bubble-primary" if user else 'chat-bubble-secondary'
    chat_class = "chat-end" if user else 'chat-start'
    return Div(cls=f"chat {chat_class}")(
               Div('user' if user else 'assistant', cls="chat-header"),
               Div(msg, cls=f"chat-bubble {bubble_class}"),
               Hidden(msg, name="messages")
           )

# The input field for the user message. Also used to clear the
# input field after sending a message via an OOB swap
def ChatInput():
    return Input(name='msg', id='msg-input', placeholder="Type a message",
                 cls="input input-bordered w-full", hx_swap_oob='true')

def list_videos_with_summaries():
    video_links = []
    for video in videos:
        if video.summary:
            video_links.append(A(video.video_id, href=f"/video/{video.video_id}"))
    return Div(*video_links, cls="video-list")

@patch
def __ft__(self:Videa):
    video_title = get_video_title(f"https://www.youtube.com/watch?v={self.video_id}")
    show = AX(video_title, f'/video/{self.video_id}', target_id="current_videos")
    # FastHTML provides some shortcuts. For instance, `Hidden` is defined as simply:
    # `return Input(type="hidden", value=value, **kwargs)`
    cts = (show, Hidden(id="video_id", value=self.video_id), Hidden(id="summary", value=self.summary), Hidden(id="session_id", value=self.session_id))
    # Any FT object can take a list of children as positional args, and a dict of attrs as keyword args.
    return Li(*cts, id=f'video-{self.video_id}')

# The main screen
@rt("/")
def get(auth, session):
    if 'auth_id' not in session: session['auth_id'] = str(uuid.uuid4())
    title = f"Welcome to {auth}'s workspace"
    top = Grid(H1(title), Div(A('logout', href='/logout'), style='text-align: right'))
    
    link_form = Form(hx_post="/youtube", hx_target="#youtube_summary", hx_swap="innerHTML")(
        Div(cls="flex space-x-2 mt-2")(Group(LinkInput(), Button("Submit", cls="btn btn-primary"))),
        Div(id='youtube_summary', hx_swap_oob='true'),
        )
    

    video_list = Card(Ul(*videos()), header=Div('History of videos'), footer=Div(id='current_videos'), id='video-list')
    
    chat_page = Form(hx_post=send, hx_target="#chatlist", hx_swap="beforeend")(
           Div(id="chatlist", cls="chat-box h-[73vh] overflow-y-auto"),
               Div(cls="flex space-x-2 mt-2")(
                   Group(ChatInput(), Button("Send", cls="btn btn-primary"))
               )
           )
    return Title(title), top, get_balance(), link_form, video_list, chat_page

# Likewise we poll to keep the balance updated
@app.get("/balance")
def get_balance():
  return Div(P(f"Global balance: {global_balance} credits"),
             id='balance', hx_get="/balance",
             hx_trigger="every 2s", hx_swap="outerHTML")

# Placeholder for an async task queue function
def prepare_for_rag(video_id, session_id):
    transcript_text = Transcript(video_id).get_transcript('en')
    rag = Rag(llm, session_id, transcript_text)
    # vector_store.add(transcript_text)
    return rag

def clr_details(): return Div(hx_swap_oob='innerHTML', id='current_videos')

@rt('/video/{video_id}')
def get(video_id:str):
    # `hx_swap` determines how the update should occur. We use "outerHTML" to replace the entire todo `Li` element.
    btn = Button('delete', hx_delete=f'/video/{video_id}',
                 target_id=f'video-{video_id}', hx_swap="outerHTML")
    # The "markdown" class is used here because that's the CSS selector we used in the JS earlier.
    # Therefore this will trigger the JS to parse the markdown in the details field.
    # Because `class` is a reserved keyword in Python, we use `cls` instead, which FastHTML auto-converts.
    return Div(Div(videos[video_id].summary, cls="scrollable-text"), btn)

@rt("/video/{video_id}")
def delete(video_id:str):
    # The `delete` method is part of the MiniDataAPI spec, removing the item with the given primary key.
    videos.delete(video_id)
    # Returning `clr_details()` ensures the details view is cleared after deletion,
    # leveraging HTMX's out-of-band swap feature.
    # Note that we are not returning *any* FT component that doesn't have an "OOB" swap, so the target element
    # inner HTML is simply deleted. That's why the deleted video is removed from the list.
    return clr_details()


@app.post("/generate_summary")
def generate_summary(video_id:str, session_id:str):
    global global_balance
    
    if global_balance < 1: return Div(P("Out of balance!"), id='summary')
    transcript_text = Transcript(video_id).get_transcript('en')
    summary_text = Summary(llm).summarize(transcript_text)
    
    global_balance -= 1 # Deduct a 1 credit for each summary generation
    try:
        videos.update({"summary":summary_text, "session_id":session_id}, video_id)
    except NotFoundError:
        videos.insert(dict(video_id=video_id, summary=summary_text, session_id=session_id))  
    return Div(summary_text, id="summary", cls="scrollable-text", )
    

# Youtube Video Frame
@app.post("/youtube")
def youtube(video_link:str):
    global rag
    video_id = link_to_videoid(video_link)    
    generate_button = Button("Generate Summary", cls="btn btn-primary", hx_post="/generate_summary", hx_target="#summary", hx_swap="outerHTML")
    try:
        v = videos[video_id]
        if v.session_id == None:
            v.update(session_id=str(uuid.uuid4()))
        session_id = v.session_id
        rag = prepare_for_rag(video_id, session_id)
        summary = Div(v.summary, id="summary", cls="scrollable-text")
    except NotFoundError:
        summary = Div('After pressing generate, it takes some to complete summarization. Please wait...', id="summary")
        session_id = str(uuid.uuid4())
        rag = prepare_for_rag(video_id, session_id=session_id)
    
    
    return Iframe(src=link_to_embed(video_link), id='youtube_video', width="560", height="315"), generate_button, summary, clr_details(), Hidden(video_id, name="video_id"), Hidden(session_id, name="session_id"), 

# Handle the form submission
@app.post
def send(msg:str, messages:list[str]=None):
    global rag, global_balance
    if not messages: messages = []
    messages.append(msg.rstrip())
    #r = llm.invoke(messages).content
    
    if global_balance < 1:
        r = "Out of balance!"
    else: 
        r = rag.generate(msg)
        global_balance -= 1 # Deduct a 1 credit for each answer generation
        
    
    return (ChatMessage(msg, True),    # The user's message
            ChatMessage(r.rstrip(), False), # The chatbot's response
            ChatInput()) # And clear the input field via an OOB swap
    
if __name__ == '__main__': uvicorn.run("main:app", host='0.0.0.0', port=int(os.getenv("PORT", default=5001)))